# 线程

线程的优点：

- 线程之间很容易共享内存。
- 创建线程的开销比较小。



# 线程的创建和启动

Java使用Thread类代表线程，所有线程对象都必须是Thread类或其子类的实例。

## 使用Thread类创建线程类

示例：

```java
public class ThreadTest extends Thread {
    private int i;
    @Override
    public void run() {
        for(; i < 100; i++) {
            System.out.println(getName()+" "+i);
        }
    }
    //main为主线程
    public static void main(String[] args) {
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName()+" "+i);
            if(i == 20) {
                new ThreadTest().start();
                new ThreadTest().start();
            }
        }

    }
}
```

执行结果（三个线程交替执行）

```
...
main 26
main 27
main 28
Thread-1 0
Thread-0 0
Thread-1 1
main 29
Thread-1 2
Thread-1 3
Thread-1 4
Thread-0 1
Thread-1 5
main 30
Thread-1 6
Thread-0 2
Thread-0 3
...
```

上述代码中，`Thread.currentThread()`方法获取当前线程对应的实例，`getName()`返回线程的名字，`setName()`可以用于设置线程的名字。

**使用继承Thread类的方法来创建线程类时，多个线程之间无法共享线程类的实例变量。**

## 使用Runnable接口创建线程类

定义Runnable接口的实现类，重写run方法，然后以Runnable对象为参数实例化Thread类。

示例：

```java
public class ThreadTest implements Runnable {
    private int i;
    @Override
    public void run() {
        for(; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + " "+i);
        }
    }
    //main为主线程
    public static void main(String[] args) {
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName()+" "+i);
            if(i == 20) {
                new Thread(new ThreadTest(), "thread_a").start();
                new Thread(new ThreadTest(), "thread_b").start();
            }
        }
    }
}
```

可以使用一个Runnable对象创建两个Thread对象，此时，两个Thread可以共享线程实例的成员变量。

```java
public class ThreadTest implements Runnable {
    private int i;
    @Override
    public void run() {
        for(; i < 100; i++) {
            System.out.println(Thread.currentThread().getName() + " "+i);
        }
    }
    //main为主线程
    public static void main(String[] args) {
        for (int i = 0; i < 100; i++) {
            System.out.println(Thread.currentThread().getName()+" "+i);
            if(i == 20) {
                Runnable r = new ThreadTest();
                new Thread(r, "thread_a").start();
                new Thread(r, "thread_b").start();
            }
        }
    }
}
```

Runnable是一个函数式接口，可以使用Lambda表达式创建实例。

## 使用Callable和Future创建线程

Callable接口提供了一个call()方法可以作为线程执行体，该方法具有返回值，并且可以抛出异常。

Java5提供了Future接口来代表Callable接口里call方法的返回值，并为其提供了`FutureTask`实现类，该类实现了Future和Runnable接口，能够作为Thread类的Target。

Future接口定义了以下的方法来控制其关联的Callable任务：

- `boolean cancel(boolean mayInterruptIfRunning)`：试图取消该Future关联的Callable任务。
- `V get()`：返回Callable任务里call方法的返回值，调用该方法将导致程序阻塞，必须等到子线程结束才会得到返回值。
- `V get(long timeout, TimeUnit unit)`：经过指定时间没有得到返回值时抛出`TimeoutException`。
- `boolean isCancelled()`：判断任务是否在正常完成前被取消。
- `boolean isDone()`

**Callable接口中的泛型与call方法的返回值相同，且Callable是函数式接口。**

示例：

```java
public class CallableTest {
    public static void main(String[] args) {
        CallableTest callableTest = new CallableTest();
        FutureTask<Integer> task = new FutureTask<Integer>((Callable<Integer>) () -> {
            int i = 0;
            for (; i < 10; i++) {
                System.out.println(Thread.currentThread().getName() + " " + i);
            }
            return i;
        });
        for (int i = 0; i < 60; i++) {
            new Thread(task, "call").start();
            System.out.println(Thread.currentThread().getName() + " " + i);
            try {
                System.out.println("return value :" + task.get());
            }catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
}
```

## 创建线程的三种方式对比

Runnable、Callable接口的优点：

- 线程类可以继承别的类。
- 多个线程可以共享一个target对象。

# 线程的生命周期

线程的状态：新建、就绪、运行、阻塞、死亡。

## 新建态和就绪态

当程序使用new创建了一个线程之后，该线程就处于新建状态，此时它和别的Java对象一样，由JVM进行管理，没有表现出现成的动态特性。

当线程对象调用了start方法后，线程转换为就绪态。Java虚拟机会为其创建方法调用栈和程序计数器，并将其加入就绪队列中，等待JVM里线程调度器的调度。

**注意：启动线程必须使用start方法。当使用run方法时，系统会将之视为一个成员方法来执行。调用run方法会破坏现成的新建态，再对其调用start会抛出`IllegalThreadStateException，start方法只能作用于新建态的线程。`**

调用start方法后，线程并不会立即执行，需要等待JVM进行调度。想要线程立即执行时，可以对主线程调用`Thread.sleep(1)`让出CPU，从而使线程能够执行。

## 运行态和阻塞态

如果处于就绪态的线程获得了CPU，开始执行run()方法的线程执行体，该线程就变成了运行状态。

当发生以下情况时，线程会进入阻塞状态：

- 线程调用sleep方法主动放弃所占用的处理器资源。
- 线程调用了一个阻塞式IO方法，在该方法返回前，线程被阻塞。
- 线程试图获得一个同步监视器，而该监视器正被其他线程持有。
- 线程在等待某个通知（notify）。
- 程序调用了线程的suspend方法将线程挂起（该方法容易导致死锁，应尽量避免使用该方法）。

线程从阻塞态进入就绪态的场景包括：

- 调用sleep方法的线程经过了指定时间。
- 线程调用的阻塞式IO方法已经返回。
- 线程成功获得了试图取得的同步监视器。
- 线程收到了特定notify。
- 挂起的线程被调用了resume方法。

![img](%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/20190208203341726.png?lastModify=1610420080)

## 线程死亡

线程有三种方式结束：

- run或call方法执行完毕。
- 线程抛出一个未捕获的Exception或Error。
- 直接调用线程的stop方法（易导致死锁）。

对线程对象调用`isAlive`方法可以测试其状态，当线程处于就绪、运行、阻塞三种状态时，该方法返回true；处于新建、死亡两种状态时，返回false。

# 控制线程

## Join线程

Thread提供了join方法让一个线程等待另一个线程完成。当在某个程序执行流中调用其他线程的join方法时，调用线程将被阻塞，直到该join方法加入的join线程执行完为之。

```java
public class JoinThread extends Thread {
    public JoinThread(String name) {
        super(name);
    }
    @Override
    public void run() {
        for (int i = 0; i < 40; i++) {
            System.out.println(getName()+" "+i);
        }
    }
    public static void main(String[] args) throws Exception {
        //新线程与main轮流执行
        new JoinThread("新线程").start();
        for (int i = 0; i < 50; i++) {
            if(i == 20) {
                JoinThread joinThread = new JoinThread("需要等待完成的线程");
                joinThread.start();
                //此时main等待joinThread完成，joinThread和新线程并发执行
                joinThread.join();
            }
            System.out.println(Thread.currentThread().getName() + " " + i);
        }
    }
}
```

join有以下三种重载形式：

- `join()`：等待被join的线程执行结束。
- `join(long mills)`：等待mills时间还未执行结束就不再等待。
- `join(long mills, int nanos)`：等待mills毫秒+`nanos`微秒。

## 后台线程

在后台运行的线程被称为后台线程（Daemon Thread），也叫“守护线程”。JVM的垃圾回收线程就是一个典型的后台线程。

后台线程有个特征：如果所有前台线程都死亡，后台线程就会自动死亡。

调用Thread对象的`setDaemon(true)`方法可以将指定线程设置为后台线程。

示例：

```java
public class Daemon extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 10000; i++) {
            System.out.println(getName() + " " + i);
        }
    }

    public static void main(String[] args) {
        Daemon t = new Daemon();
        t.setDaemon(true);
        t.start();
        for (int i = 0; i < 10; i++) {
            System.out.println(Thread.currentThread().getName() + " " + i);
        }
        //程序执行到此处时前台线程结束，随后后台也会自动结束
    }
}
```

前台线程创建的子线程默认为前台线程，后台线程创建的子线程默认为后台线程。

`setDaemon`方法必须在`start`方法调用之前调用。

## 线程休眠

如果需要让当前线程暂停一段时间，进入阻塞态，可以通过调用Thread类的静态方法sleep。
- `static void sleep(long millis)`：暂停`millis`毫秒。
- `static void sleep(long mills, int nanos)`：暂停`millis+nanos`时间。

示例：

```java
public static void main(String[] args) throws InterruptedException {
    for (int i = 0; i < 10; i++) {
        System.out.println(i);
    }
    Thread.sleep(10);
}
```

## 线程让步：yield

yield方法是一个和sleep()方法有点相似的方法，它也是Thread类提供的一个静态方法，会使得当前正在执行的线程暂停，并加入就绪队列。调用yield之后，线程调度器会重新调度一次线程。

## 改变线程优先级

每个线程的默认优先级与创建它的父线程的优先级相同，在默认情况下，main线程具有普通优先级，其创建的子线程也具有普通优先级（即`Thread.NORM_PRIORITY`）。

Thread类提供了`setPriority(int newPriority)、getPriority()`方法来设置和返回指定线程的优先级，其中`setPriority`方法的参数是一个1-10之间的整数。Thread类提供了以下的三个优先级宏：

- MAX_PRIORITY    10
- MIN_PRIORITY    1
- NORM_PRIORITY    5

示例：

 ```java
public class PriorityTest extends Thread {
    @Override
    public void run() {
        for (int i = 0; i < 50; i++) {
            System.out.println(getName()+",其优先级为："+getPriority()+",i="+i);
        }
    }

    public PriorityTest(String s) {
        super(s);
    }

    public static void main(String[] args) {
        Thread.currentThread().setPriority(6);
        for (int i = 0; i < 30; i++) {
            if(i==10) {
                PriorityTest pt1 = new PriorityTest("low");
                //默认优先级为6
                pt1.start();
                pt1.setPriority(Thread.MIN_PRIORITY);
            }
            if(i==20) {
                PriorityTest pt2 = new PriorityTest("high");
                pt2.start();
                pt2.setPriority(Thread.MAX_PRIORITY);
            }
        }
    }
}
 ```

输出：

```
low,其优先级为：1,i=0
high,其优先级为：10,i=0
low,其优先级为：1,i=1
high,其优先级为：10,i=1
low,其优先级为：1,i=2
high,其优先级为：10,i=2
low,其优先级为：1,i=3
high,其优先级为：10,i=3
...
```

# 线程同步

## 同步代码块

为了解决线程同步的问题，Java引入了同步监视器，使用同步监视器的通用方法是同步代码块，语法格式为：

```java
synchronized(obj) {
    //同步代码块
}
```

`obj`就是同步监视器，线程开始执行同步代码块之前，要先获得`obj`的锁。

**tips：任何时候只能有一个线程获得同步监视器的锁，同步代码块执行结束后，线程会释放锁。**

通常使用可以被并发访问的共享资源充当同步监视器。

```java
import java.util.Objects;

public class DrawThread extends Thread {
    private Account account;
    private double drawAmount;
    public DrawThread(String name, Account account, double drawAmount) {
        super(name);
        this.account = account;
        this.drawAmount = drawAmount;
    }

    @Override
    public void run() {
        synchronized (account) {
            if(account.getBalance() >= drawAmount) {
                System.out.println(getName()+"取钱成功，取出：$"+drawAmount);
                account.setBalance(account.getBalance()-drawAmount);
                System.out.println("余额为："+account.getBalance());
            }else {
                System.out.println("余额不足！");
            }
        }
    }

    public static void main(String[] args) {
        Account account = new Account("root", 1000);
        DrawThread t1 = new DrawThread("a", account, 600);
        DrawThread t2 = new DrawThread("b", account, 600);
        t1.start();
        t2.start();
    }
}
class Account {
    private String accountNo;
    private double balance;

    public Account(String accountNo, double balance) {
        this.accountNo = accountNo;
        this.balance = balance;
    }

    public Account() {
    }

    public String getAccountNo() {
        return accountNo;
    }

    public void setAccountNo(String accountNo) {
        this.accountNo = accountNo;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Account account = (Account) o;
        return Objects.equals(accountNo, account.getAccountNo());
    }

    @Override
    public int hashCode() {
        return Objects.hash(accountNo);
    }
}
```

输出：

```
a取钱成功，取出：$600.0
余额为：400.0
余额不足！
```

## 同步方法

Java还为多线程安全提供了同步方法，即使用synchronized关键字修饰的方法。对于synchronized修饰的实例方法，无需显式指定同步监视器，其同步监视器是this，即调用该方法的对象。

上面的例子中，为Account类添加一个synchronized方法即能方便的实现线程同步。

```java
public class DrawThread extends Thread {
    private Account account;
    private double drawAmount;
    public DrawThread(String name, Account account, double drawAmount) {
        super(name);
        this.account = account;
        this.drawAmount = drawAmount;
    }

    @Override
    public void run() {
        account.draw(drawAmount);
    }

    public static void main(String[] args) {
        Account account = new Account("root", 1000);
        DrawThread t1 = new DrawThread("a", account, 600);
        DrawThread t2 = new DrawThread("b", account, 600);
        t1.start();
        t2.start();
    }
}
class Account {
    private String accountNo;
    private double balance;

    public Account(String accountNo, double balance) {
        this.accountNo = accountNo;
        this.balance = balance;
    }

    public Account() {
    }

    public String getAccountNo() {
        return accountNo;
    }

    public void setAccountNo(String accountNo) {
        this.accountNo = accountNo;
    }

    public double getBalance() {
        return balance;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Account account = (Account) o;
        return Objects.equals(accountNo, account.getAccountNo());
    }

    @Override
    public int hashCode() {
        return Objects.hash(accountNo);
    }

    public synchronized void draw(double drawAmount) {
        if(balance >= drawAmount) {
            System.out.println(Thread.currentThread().getName()+"取钱成功，取出：$"+drawAmount);
            balance -= drawAmount;
            System.out.println("余额为：$" + balance);
        }else {
            System.out.println("余额不足！");
        }
    }
}
```

**在Account里定义draw方法更符合面向对象的规则。**

## 释放同步监视器的锁定

线程释放同步监视器的情况：

- 当前线程的同步代码块或同步方法执行结束；
- 当前线程在同步代码块、同步方法中遇到了break、return终止了该代码块或该方法的继续执行；
- 当前线程在同步代码块、同步方法中遇到了未处理的Error或Exception；
- 当前线程在执行同步代码块、同步方法时执行了同步监视器对象（同步代码块的`obj`或者同步方法的this对象）的wait()方法，则当前线程暂停，并释放同步监视器（wait方法属于Object类）。

在下列情况下，线程不会释放同步监视器：

- 执行同步代码块或同步方法时，调用`Thread.sleep()`或`Thread.yield()`方法来暂停当前线程。

## Lock

> 可重入锁：某个线程已经获得某个锁，可以再次获取锁而不会出现死锁。
>
> 可中断锁：可中断锁就是可以响应中断的锁。在Java中，synchronized不是可中断锁，而Lock是可中断锁。如果某一线程A正在执行锁中的代码，另一线程B正在等待获取该锁，可能由于等待时间过长，线程B不想等待了，想先处理其他事情，我们可以让它中断自己或者别的线程中断它。
>
> 公平锁：公平锁即尽量保证线程以请求锁的顺序来获取锁。比如，多个线程等待一个锁，当这个锁被释放时，等待时间最久的线程会获得该锁。而非公平锁则无法保证锁的获取按照请求锁的顺序进行，可能导致某个或者一些线程永远获取不到锁。

Java5可以通过显式定义同步锁对象来实现同步，由Lock对象充当同步锁。

Lock是控制多个线程对共享资源进行访问的工具。通常锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象。

`ReadWriteLock`（读写锁）允许对共享资源并发访问。Lock、`ReadWriteLock`是Java5提供的两个根接口，并为Lock提供了`ReentrantLock`（可重入锁）实现类，为`ReadWriteLock`提供了`ReentrantReadWriteLock`实现类。

`ReentrantLock`比较常用，示例：

对上例中的Account类作以下修改，可以保证对于一个account对象，某一时刻只有一个线程可以获取lock锁。

```java
class Account {
    //define lock
    private final ReentrantLock lock = new ReentrantLock();

    private String accountNo;
    private double balance;

    public Account(String accountNo, double balance) {
        this.accountNo = accountNo;
        this.balance = balance;
    }

    public String getAccountNo() {
        return accountNo;
    }

    public void setAccountNo(String accountNo) {
        this.accountNo = accountNo;
    }

    public double getBalance() {
        return balance;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Account account = (Account) o;
        return Objects.equals(accountNo, account.getAccountNo());
    }

    @Override
    public int hashCode() {
        return Objects.hash(accountNo);
    }

    public synchronized void draw(double drawAmount) {
        lock.lock();
        try {
            if(balance >= drawAmount) {
                System.out.println(Thread.currentThread().getName()+"取钱成功，取出：$"+drawAmount);
                balance -= drawAmount;
                System.out.println("余额为：$" + balance);
            }else {
                System.out.println("余额不足！");
            }
        }finally {
            lock.unlock();
        }
    }
}
```

`ReentrantLock`锁具有可重入性，也就是说，一个线程可以对已被加锁的`ReentrantLock` 锁再次加锁，`ReentrantLock`对象会维持一个计数器来追踪`lock()`方法的嵌套调用，线程在每次调用`lock()`加锁后，必须显式调用`unlock()`来释放锁，所以一段被锁保护的代码可以调用另一个被相同锁保护的方法。

`ReentrantLock`锁的构造方法中不传入参数或传入true时，产生公平锁，传入false时，产生非公平锁。

> 公平锁：以请求锁的顺序获得锁。
>
> 非公平锁：不保证锁的公平性，如synchronized。

**Lock要求用户手动释放锁，如果没有主动释放锁，就有可能导致出现死锁现象。**

`tryLock()`与`tryLock(long time, TimeUnit unit)`是比较常用的两个方法，并且体现了Lock的可中断性。

`tryLock()`方法具有返回值，它表示尝试获取锁，如果获取成功，则返回true；如果获取失败（即锁已被其他线程获取），则返回false，也就是说，这个方法无论如何都会立即返回（在拿不到锁时不会一直在那等待）。

`tryLock(long time, TimeUnit unit)`方法和`tryLock()`方法类似，只不过这个方法在拿不到锁时会等待一定的时间，在时间期限之内如果还拿不到锁，就返回false，同时可以响应中断。如果一开始拿到锁或者在等待期间内拿到了锁，则返回true。

一般情况下，通过`tryLock`来获取锁时是这样使用的：

```java
Lock lock = ...;
if(lock.tryLock()) {
     try{
         //处理任务
     }catch(Exception ex){
		//处理异常
     }finally{
         lock.unlock();   //释放锁
     } 
}else {
    //如果不能获取锁，则直接做其他事情
}
```

**Lock与synchronized的区别：**

1. `synchronized`是Java语言的关键字，因此是内置特性，`Lock`不是Java语言内置的，Lock是一个接口，通过实现类可以实现同步访问。

2. `synchronized`是在JVM层面上实现的，不但可以通过一些监控工具监控`synchronized`的锁定，而且在代码执行时出现异常，JVM会自动释放锁定，但是使用Lock则不行，`Lock`是通过代码实现的，要保证锁定一定会被释放，就必须将`unLock()`放到`finally{}`中

3. 在资源竞争不是很激烈的情况下，`synchronized`的性能要优于`ReetrantLock`，但是在资源竞争很激烈的情况下，`synchronized`的性能会下降几十倍，但是`ReetrantLock`的性能能维持常态。

# 线程通信

## 传统的线程通信

假设现在系统中有两个线程,这两个线程分别代表存款者和取钱者——现在假设系统有一种特殊的要求，系统要求存款者和取钱者不断地重复存款、取钱的动作，而且要求每当存款者将钱存入指定账户后，取钱者就立即取出该笔钱。不允许存款者连续两次存钱，也不允许取钱者连续两次取钱。

为了实现这种功能，可以借助于Object类提供的`wait()`、`notify()`和`notifyAll()`三个方法，这三个方法并不属于Thread类，而是属于Object类。但这三个方法必须由同步监视器对象来调用，这可分成以下两种情况。

- 对于使用synchronized修饰的同步方法，因为该类的默认实例( this）就是同步监视器，所以可以在同步方法中直接调用这三个方法。
- 对于使用synchronized修饰的同步代码块，同步监视器是synchronized后括号里的对象，所以必须使用该对象调用这三个方法。

这三个方法的功能如下：

- `wait()`：导致当前线程等待，直到其他线程调用该同步监视器的`notify()`方法或`notifyAll()`方法来唤醒该线程。调用无参的wait时，会一直等待直到其他线程通知，调用有参wait时，会在等待指定时间后自动苏醒。调用wait方法的线程会立即释放对同步监视器的锁定。
- `notify()`：唤醒在此同步监视器上等待的单个线程。如果所有线程都在该同步监视器上等待，则会随机选择唤醒其中一个线程。只有当前线程放弃对同步监视器的锁定，才可以执行被唤醒的线程。
- `notifyAll()`：唤醒在此同步监视器上等待的所有线程。

示例：

```java
public class Account {

    private String accountNo;
    private double balance;
    private boolean flag = false;

    public Account(String accountNo, double balance) {
        this.accountNo = accountNo;
        this.balance = balance;
    }

    public String getAccountNo() {
        return accountNo;
    }

    public void setAccountNo(String accountNo) {
        this.accountNo = accountNo;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Account account = (Account) o;
        return Objects.equals(accountNo, account.getAccountNo());
    }

    @Override
    public int hashCode() {
        return Objects.hash(accountNo);
    }

    public synchronized void draw(double drawAmount) {
        try {
            if (!flag) {
                wait();
            } else {
                System.out.println(Thread.currentThread().getName() + "取钱" + drawAmount);
                balance -= drawAmount;
                System.out.println("余额为："+balance);
                flag = false;
                notifyAll();
            }
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }
    }

    public synchronized void deposit(double depositAmount) {
        try {
            if(flag) {
                wait();
            }else {
                System.out.println(Thread.currentThread().getName() + "存款" + depositAmount);
                balance += depositAmount;
                System.out.println("余额为："+balance);
                flag = true;
                notifyAll();
            }
        }catch (InterruptedException ex) {
            ex.printStackTrace();
        }
    }
}
```

##  使用Condition控制线程通信

程序使用Lock对象来进行同步时，只能使用Java提供的Condition类来控制线程通信。使用Condition可以让那些已经得到Lock对象但无法继续执行的线程释放Lock对象，或唤醒其他处于等待状态的线程。

Condition实例被绑定在一个Lock对象上。要获得特定Lock实例的Condition实例，调用Lock对象的`newCondition`方法即可。Condition类提供了如下三个方法：

- `await()`：类似wait方法。
- `signal()`：类似notify方法。
- `signalAll()`：类似notifyAll方法。

示例：

```java
import java.util.Objects;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;
import java.util.concurrent.locks.ReentrantLock;

public class Account {

    private String accountNo;
    private double balance;
    private boolean flag = false;
    private final Lock lock = new ReentrantLock();
    private final Condition condition = lock.newCondition();

    public Account(String accountNo, double balance) {
        this.accountNo = accountNo;
        this.balance = balance;
    }

    public String getAccountNo() {
        return accountNo;
    }

    public void setAccountNo(String accountNo) {
        this.accountNo = accountNo;
    }

    public double getBalance() {
        return balance;
    }

    public void setBalance(double balance) {
        this.balance = balance;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Account account = (Account) o;
        return Objects.equals(accountNo, account.getAccountNo());
    }

    @Override
    public int hashCode() {
        return Objects.hash(accountNo);
    }

    public void draw(double drawAmount) {
        lock.lock();
        try {
            if (!flag) {
                condition.await();
            } else {
                System.out.println(Thread.currentThread().getName() + "取钱" + drawAmount);
                balance -= drawAmount;
                System.out.println("余额为："+balance);
                flag = false;
                condition.signal();
            }
        } catch (InterruptedException ex) {
            ex.printStackTrace();
        }finally {
            lock.unlock();
        }
    }

    public void deposit(double depositAmount) {
        lock.lock();
        try {
            if(flag) {
                condition.await();
            }else {
                System.out.println(Thread.currentThread().getName() + "存款" + depositAmount);
                balance += depositAmount;
                System.out.println("余额为："+balance);
                flag = true;
                condition.signal();
            }
        }catch (InterruptedException ex) {
            ex.printStackTrace();
        }finally {
            lock.unlock();
        }
    }
}
```

与同步代码块的使用几乎相同，只是使用Lock作为同步监视器，使用Condition对象来暂停、唤醒线程。

## 使用BlockingQueue进行线程通信

`BlockingQueue`是Queue的一个子接口，它的主要用途不是用于容器，而是作为线程同步的工具。`BlockingQueue`具有一个特征：当生产者试图向`BlockingQueue`中放入元素时，如果该队列已满，则该线程被阻塞；当消费者线程试图从`BlockingQueue`中取出元素时，如果该队列已空，则该线程被阻塞。

程序的两个线程交替向`BlockingQueue`中放入或取出元素，可以很方便的控制线程通信。

BlockingQueue提供了以下两个支持阻塞的方法：

- `put(E e)`：尝试将元素e放入队列，如果队列元素已满，则阻塞该线程。
- `take()`：尝试从队列头部取出元素，如果该队列元素已满，则阻塞该线程。

BlockingQueue继承了Queue接口，其方法归纳起来可分为以下三组：

- 在队尾插入元素：包括add、offer、put方法，队列已满时，三种方法分别会抛出异常、返回false、阻塞线程。
- 在队头取出元素：包括remove、poll、take方法，队列为空时，三种方法分别会抛出异常、返回false、阻塞线程。
- 获取队头元素：element和peek方法，队列为空时分别会抛出异常、返回false。

`BlockingQueue`与其实现类的关系如图所示：

![preview](%E5%A4%9A%E7%BA%BF%E7%A8%8B.assets/2e6bv3HOdruXTDt.jpg)

BlockingQueue具有五个基本的实现类：

- `ArrayBlockingQuque`：底层实现数组、先入先出、有界队列，构造时需指定数组长度且不可变，`ReentrantLock`、`Condition`实现线程安全；
- `LinkedBlockingQueue`：底层实现链表，先入先出、无界队列，`ReentrantLock`、`Condition`实现线程安全，可以指定最大容量，默认为`Integer.MAX_VALUE`；
- `PriorityBlockingQueue`：底层数组实现二叉堆，数组可变，所以是支持优先级无界阻塞队列，`ReentrantLock`、`Condition`实现线程安全；
- `DelayQueue`：底层数据是`PriorityQueue`（无锁无阻塞无界优先级队列），`ReentrantLock`、`Condition`实现线程安全，保存元素必须实现Delayed接口，可以指定元素出队时间；
- `SynchronousQueue`：没有容量，不管是take还是put进来的线程，如果没有匹配就阻塞，等待异类线程交换数据并唤醒，支持公平与非公平模式，无锁通过CAS实现；

示例：

生产者：

```java
import java.util.Random;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

/**
 * 生产者线程
 *
 * @author jackyuj
 */
public class Producer implements Runnable {

    private volatile boolean  isRunning = true;//是否在运行标志
    private BlockingQueue queue;//阻塞队列
    private static AtomicInteger count = new AtomicInteger();//自动更新的值
    private static final int DEFAULT_RANGE_FOR_SLEEP = 1000;

    //构造函数
    public Producer(BlockingQueue queue) {
        this.queue = queue;
    }

    public void run() {
        String data = null;
        Random r = new Random();

        System.out.println("启动生产者线程！");
        try {
            while (isRunning) {
                System.out.println("正在生产数据...");
                Thread.sleep(r.nextInt(DEFAULT_RANGE_FOR_SLEEP));//取0~DEFAULT_RANGE_FOR_SLEEP值的一个随机数

                data = "data:" + count.incrementAndGet();//以原子方式将count当前值加1
                System.out.println("将数据：" + data + "放入队列...");
                if (!queue.offer(data, 2, TimeUnit.SECONDS)) {//设定的等待时间为2s，如果超过2s还没加进去返回true
                    System.out.println("放入数据失败：" + data);
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
            Thread.currentThread().interrupt();
        } finally {
            System.out.println("退出生产者线程！");
        }
    }

    public void stop() {
        isRunning = false;
    }
}
```

消费者：

```java
import java.util.Random;
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.TimeUnit;

/**
 * 消费者线程
 *
 * @author jackyuj
 */
public class Consumer implements Runnable {

    private BlockingQueue<String> queue;
    private static final int DEFAULT_RANGE_FOR_SLEEP = 1000;

    //构造函数
    public Consumer(BlockingQueue<String> queue) {
        this.queue = queue;
    }

    public void run() {
        System.out.println("启动消费者线程！");
        Random r = new Random();
        boolean isRunning = true;
        try {
            while (isRunning) {
                System.out.println("正从队列获取数据...");
                String data = queue.poll(2, TimeUnit.SECONDS);//有数据时直接从队列的队首取走，无数据时阻塞，在2s内有数据，取走，超过2s还没数据，返回失败
                if (null != data) {
                    System.out.println("拿到数据：" + data);
                    System.out.println("正在消费数据：" + data);
                    Thread.sleep(r.nextInt(DEFAULT_RANGE_FOR_SLEEP));
                } else {
                    // 超过2s还没数据，认为所有生产线程都已经退出，自动退出消费线程。
                    isRunning = false;
                }
            }
        } catch (InterruptedException e) {
            e.printStackTrace();
            Thread.currentThread().interrupt();
        } finally {
            System.out.println("退出消费者线程！");
        }
    }

}
```

测试类：

```java
import java.util.concurrent.BlockingQueue;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.LinkedBlockingQueue;

public class BlockingQueueTest {

    public static void main(String[] args) throws InterruptedException {
        // 声明一个容量为10的缓存队列
        BlockingQueue<String> queue = new LinkedBlockingQueue<String>(10);

        //new了三个生产者和一个消费者
        Producer producer1 = new Producer(queue);
        Producer producer2 = new Producer(queue);
        Producer producer3 = new Producer(queue);
        Consumer consumer = new Consumer(queue);

        // 借助Executors
        ExecutorService service = Executors.newCachedThreadPool();
        // 启动线程
        service.execute(producer1);
        service.execute(producer2);
        service.execute(producer3);
        service.execute(consumer);

        // 执行10s
        Thread.sleep(10 * 1000);
        producer1.stop();
        producer2.stop();
        producer3.stop();

        Thread.sleep(2000);
        // 退出Executor
        service.shutdown();
    }
}
```

## 线程组

Java使用`ThreadGroup`来表示线程组，它可以对一批线程进行分类管理，Java允许程序直接对线程组进行控制。对线程组的控制相当于同时控制这批线程。用户创建的所有线程都属于指定线程组，如果程序没有显式指定线程属于哪个线程组，则该线程属于默认线程组。在默认情况下，子线程和创建它的父线程处于同一个线程组内，例如A线程创建了B线程，并且没有指定B线程的线程组，则B线程属于A线程所在的线程组。

一旦某个线程加入了指定线程组之后，该线程将一直属于该线程组，直到该线程死亡，线程运行中途不能改变它所属的线程组。

Thread类提供了如下几个构造器来设置新创建的线程属于哪个线程组：

- `Thread(ThreadGroup group, Runnable target)`
- `Thread(ThreadGroup group, Runnable target, String name)`
- `Thread(ThreadGroup group, String name)`

Thread对象可以通过`getThreadGroup`方法获取当前线程的`ThreadGroup`对象。`ThreadGroup`类提供了两个构造器：

- `ThreadGroup(String name)`
- `ThreadGroup(ThreadGroup parent, String name)`：指定线程组的父线程组。

`ThreadGroup`类提供了以下的方法操作线程组的所有线程：

- `int activeCount()`：返回线程组中活动线程的数目。
- `interrupt()`：中断线程组的所有线程。
- `isDaemon()`：判断线程组是否为后台线程组。
- `setDaemon()`：将线程组设置为后台线程组（当后台线程组的最后一个线程执行结束后，后台线程组会自动销毁）。
- `setMaxPriority(int priority)`：设置线程组的最高优先级。

# 线程池

系统启动一个新线程的成本比较高，利用线程池可以很好地提高性能，尤其是在程序中需要创建大量生存期很短暂的线程时。

线程池在系统启动时即创建大量的线程，程序将一个Runnable对象或Callable对象传给线程池，线程池启动一个线程来执行其run或call方法，执行结束后线程返回线程池并成为空闲状态。

除此之外，使用线程池可以有效地控制系统中并发线程的数量，当系统中包含大量并发线程时，会导致系统性能剧烈下降，甚至导致JVM崩溃，而线程池的最大线程数参数可以控制系统中并发线程数不超过此数。

Java5新增了一个Executors工厂类来产生线程池，该工厂类包含如下几个静态工厂方法来创建线程池。

- `ExecutorService new CachedThreadPool()`：创建一个具有缓存功能的线程池，系统根据需要创建线程，这些线程将会被缓存到线程池中。
- `ExecutorService new FixedThreadPool(int nThreads)`：创建一个可重用的，数量固定的线程池。
- `ExecutorService new SingleThreadExecutor()`：相当于`new FixedThreadPool(1)`。
- `ScheduledExecutorService new ScheduledThreadPool(int poolSize)`：创建具有指定线程数，并在指定延迟后执行线程任务的线程池。
- `ScheduledExecutorService new SingleThreadScheduledExecutor()`
- `ExecutorService newWorkStealingPool(int parallelism)`：创建持有足够的线程的线程池来支持给定的并行级别，该方法还会使用多个队列来减少竞争。

`ExecutorService` 代表尽快执行线程的线程池（只要线程池中有空闲线程，就立即执行线程任务)程序只要将一个Runnable对象或Callable对象（代表线程任务）提交给该线程池，该线程池就会尽快执行该任务。`ExecutorService` 里提供了如下三个方法。

- `Future<?> submit(Runnable task)`：将一个Runnable对象提交给指定的线程池，线程池将在有空闲线程时执行Runnable对象代表的任务。
- `<T>Future<T> submit(Runnable task, T result)`：result显式指定线程执行结束后的返回值，所以Future对象将在run方法执行结束后返回result。

示例：

```java
public class Test {
    public static void main(String[] args) throws Exception {
        ExecutorService pool = Executors.newFixedThreadPool(5);
        Runnable target = () -> {
            for (int i = 0; i < 10; i++) {
                System.out.println(Thread.currentThread().getName() + "i="+ i);
            }
        };
        pool.submit(target);
        pool.submit(target);
        pool.shutdown();
    }
}
```

