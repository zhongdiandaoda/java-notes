# Overview

 An object is considered garbage when it can no longer be reached from any pointer in the running program.

# 垃圾对象标记算法

## 引用计数算法

在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；引用失效时，计数器值就减一；任何时刻计数器为0的对象就是需要被回收的对象。

引用计数器算法的原理简单，判定效率也很高，但**主流的虚拟机都没有选用引用计数算法**，原因是它必须配合大量额外处理才能正确地工作。比如，单纯的引用计数算法无法解决对象间循环引用的问题。

Python中支持引用计数算法，它通过一个额外的标准库解决对象的循环引用问题。

例如：

```java
public static void main(String[] args) {
    Demo a = new Demo();
    Demo b = new Demo();
    a.instance = b;
    b.instance = a;
    a = null;
    b = null;
    System.gc();
}
```

## 可达性分析算法

也叫根搜索算法或追踪性垃圾收集算法，可以有效解决循环引用问题，防止内存泄漏的发生。

通过一系列称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程走过的路径叫做”引用链“，如果从GC Roots到某个对象不可达，则该对象是需要被回收的对象。

<img src="垃圾回收与内存分配.assets/image-20210324151352045.png" alt="image-20210324151352045" style="zoom: 67%;" />

在Java语言中，GC Roots包含以下几类元素：

- 虚拟机栈中引用的对象，如各个线程被调用的方法中的局部变量、参数等。
- 本地方法栈中引用的对象。
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象，如常量池中的引用
- 被同步锁持有的对象
- JVM内部的引用



# 引用

JDK1.2后，Java对引用的概念进行了扩充，将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)和虚引用(Phantom Reference)。

- 强引用：传统的引用，例如`Object obj = new Object()`，任何情况下，只要强引用关系存在，GC就不会回收被引用的对象。

- 软引用：一些有用但非必须的对象。系统在将要发生内存溢出异常时会将这些对象列进回收范围进行第二次回收。
- 弱引用：一些非必须的对象。当GC开始工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。
- 虚引用：一个对象是否有虚引用的存在，完全不会对其生存时间产生影响，也无法通过虚引用取得一个对象实例，虚引用的作用是在对象被回收后收到一个系统通知。

# 回收方法区

方法区的垃圾收集主要回收废弃的常量和不再使用的类型。

- 常量：例如，一个字符串常量“jar”，如果当前系统中没有任何地方引用这个字面量，且虚拟机中没有其他地方引用这个字面量，就可以将这个常量清除出方法区。
- 类：条件较为苛刻。

# 垃圾收集算法

## 分代收集理论

分代收集理论建立在三个假说之上：

1. 弱分代假说：绝大多数对象都是朝生夕死的。
2. 强分代假说：熬过越多次垃圾收集过程的对象越难以消亡。
3. 跨代引用假说：跨代引用相对于同代引用来说仅占极少数。

垃圾收集器一致的设计原则：将Java堆分出不同的区域，然后将回收对象根据其年龄分配到不同的区域之中存储。设计者一般会把堆划分为新生代和老生代两个区域。

在新生代中，只要标记少量存活对象即可；对于老生代，可以降低回收该区域的频率以降低时间开销。

为了解决跨代引用的问题，需要在新生代建立一个数据结构存储老生代中发生了跨代引用的区域，在回收新生代时仅扫描发生了跨代引用的老生代区域即可。

新生代收集（`MinorGC/YoungGC`）

老生代收集（`MajorGC/OldGC`）

## 标记清除算法

标记垃圾，清除垃圾或标记存活，清除垃圾。

缺点：

- 执行效率不稳定。当多数对象都可回收时，需要进行大量标记和清除的动作。
- 内存空间碎片化问题。

<img src="垃圾回收与内存分配.assets/image-20210324161337658.png" alt="image-20210324161337658" style="zoom:67%;" />

## 标记复制算法

将内存空间分为大小相等的两块，每次只使用其中的一块。当清理完一块的垃圾后，将其中存活的对象全部复制到另一块中的连续内存区域，再把之前整块内存都一次清理掉。

当块中大多数对象都可回收时，仅需要复制少量存活对象，此时算法效率较高。复制后对象连续存储，因此不会存在内存碎片。

缺陷是浪费了一半的内存空间。



<img src="垃圾回收与内存分配.assets/image-20210324161323824.png" alt="image-20210324161323824" style="zoom:67%;" />

现在的商用Java虚拟机大多都优先采用了这种收集算法回收新生代。

新生代中大部分对象都熬不过第一轮收集，因此并不需要按照1比1的比例来划分新生代的内存空间。

Appel式回收：

将新生代分为一块较大的Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和一块Survivor，发生GC时将Eden和Survivor中的存活对象复制到另一块Survivor中。默认比例为8:1:1。

当Survivor区域内存不足时，就需要找老生代借空间，添加额外的空间分配担保程序。

## 标记整理算法

老生代一般不会采用标记复制算法。

标记整理算法在标记垃圾后，让所有存活的对象向内存空间一端移动，然后直接清理掉边界以外的内存。

<img src="垃圾回收与内存分配.assets/image-20210324162551615.png" alt="image-20210324162551615" style="zoom:67%;" />

这种算法更适用于老生代。

缺陷是移动存活对象时，要更新所有引用这些对象的地方，且在执行移动操作时必须暂停用户应用程序，这样的停顿被最初的虚拟机设计者描述为“Stop The World”。

如果不移动对象，就需要通过更复杂的内存分配器和内存访问其来解决空间碎片化问题，降低内存访问效率。



一种和稀泥式的方案是平时执行标记清除算法，内存碎片过多时再执行一次标记整理算法。

## Hot Spot实现



# 垃圾收集器

## Serial收集器

Serial是最基础、历史最悠久的收集器，是一个单线程工作的收集器。

它在进行垃圾收集时，会暂停其他所有工作线程，直到收集结束。

![image-20210325000312651](%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20210325000312651.png)

目前，它仍是Hot Spot虚拟机在客户端客户端模式下的默认收集器。

Serial收集器没有线程交互的开销，在资源受限的环境中拥有很好的表现。

在微服务应用中，由于虚拟机管理的内存一般比较小，垃圾收集的停顿时间往往在几十毫秒，Serial收集器是一个很好的选择。

## Parallel New收集器

`ParNew`收集器是Serial收集器的多线程并行版本，除了同时使用多条线程进行垃圾收集之外，其余的行为，包括Serial收集器可用的所有控制参数（例如：`-XX:SurvivorRatio,-XX:PretenureSizeThreshold`等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一致。

![image-20210325003507628](%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20210325003507628.png)

JDK1.5中，`ParNew`和CMS（老生代并行收集器）配合作为服务器端推荐的收集器。

只有`ParNew`和Serial收集器能够与CMS收集器配合工作。

JDK9开始，面向全堆的G1收集器取代了`ParNew`收集器。

## Parallel Scavenge

不同于其他收集器，追求尽量缩短垃圾收集时用户线程的停顿时间，Parallel Scavenge收集器的设计目的是达到一个可控制的吞吐量。
$$
吞吐量 = \frac{运行用户代码时间}{运行用户代码时间+运行垃圾收集时间}
$$


它提供了参数用来精确控制吞吐量。

## Serial Old收集器

Serial Old是Serial收集器的老生代版本，同样是一个单线程收集器，使用标记整理算法。

![image-20210325213302280](%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20210325213302280.png)

Serial Old收集器的主要用法是和Parallel Scavenge收集器搭配使用或者作为CMS收集器发生失败时的后备预案。

## Parallel Old收集器

Parallel Old是Parallel Scavenge收集器的老生代版本，支持多线程并发收集，基于标记整理算法实现，能够与Parallel Scavenge收集器配合工作。

![image-20210325214807656](%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20210325214807656.png)

## CMS收集器

CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。

CMS收集器是基于标记清除算法实现的，其执行过程可以分为以下四个阶段：

1. 初始标记：标记GC Roots能直接关联到的对象，时间较短。
2. 并发标记：从GC Roots的直接关联对象开始遍历整个对象图。
3. 重新标记：修正并发标记阶段因用户程序继续运行而产生变动的那一部分对象的标记记录，比并发标记阶段时间短，比初始标记阶段时间长。
4. 并发清除：清理标记阶段判断的已经死亡的对象。

初始标记和重新标记两个步骤需要“Stop The World”。

![image-20210325234248832](%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D.assets/image-20210325234248832.png)

## Garbage First收集器

Garbage First（简称G1）收集器是一款面向服务端的垃圾收集器。

在JDK9之后，G1宣布取代Parallel Scavenge加Parallel Old组合，成为服务端模式下的默认垃圾收集器。

G1之前的收集器的回收范围是新生代、老生代或Java堆，而G1跳出了这个限制，可以面向堆内存的任意部分组成回收集进行回收。

G1基于Region来实现垃圾收集，将堆内存划分成若干个大小相等的独立区域，每一个Region都可以根据需求去扮演新生代的Eden空间、Survivor空间或者老生代空间。

…